Adam Sachs
ajs2255
HW1 -- README

1) My program first checks if k=0--and if it does, it simply returns the matrix A that it was given, as when k=0, we simply want to return A^1, i.e. A. If k>0, then the program enters a 'for' loop which is executed k times. Each execution of the 'for' loop first multiplies matrix A by itself. It does this by 3 nested 'for' loops--two outer loops to cycle through each component of the final product matrix (A^2), then the third loop cycles through the corresponding row/column in each factor matrix (matrix A), adding individual products to compute the appropriate dot product. I.e. for component [i,j] of the product matrix A^2, it cycle through z=1,2,â€¦n computing A[i,z]*A[z,j], adding each of these products to a holder value that represents the dot product, which it then plugs into component [i,j] of the product matrix A^2 (which is held in a temporary array called 'holderarray'). It then places the product matrix held in 'holderarray' back into the original matrix A, so that if k>1 and the loop is repeated, we will effectively be multiplying (A^2)*(A^2), i.e. we will be computing (A^2)^2 in 2 matrix multiplications, as the problem asks (the 2 here can be generalized to any value 'k', as the loop will repeat accordingly 'k' times). When the outmost 'k' loop stops executing, the program simply outputs the A matrix (stored in 'arrayA'), as this matrix is always holding the product matrix of the last matrix multiplication, i.e. the matrix we are looking for.

3) My program is written in C. Its name is 'matrixmult.c'.  In order to compile, type the command 'gcc matrixmult.c -o matrixmult', and then in order to run type the command './matrixmult input_file_name output_file_name'. 