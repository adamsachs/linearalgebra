Adam Sachs
ajs2255
HW 3--README

1) My program first forms an augmented matrix with the coefficient matrix and the b vector. It then puts this vector in reduced row echelon form by performing forward elimination, back elimination, and then dividing each row by its corresponding pivot value. It also determines the rank of the matrix, incrementing the rank counter by one every time it encounters a non-zero pivot value.

After forming rref(A), the program then finds the solution to the system.

If the rank is equal to both n and m, then we have a square and invertible matrix, so the unique solution is simply the values that are in the b column of the matrix. 

If the rank is equal to n but is less than m, then we have a full column rank matrix but we have free rows, so the program checks that the b value for these free rows is 0 (i.e. checks to see if we have 0=0 in the free rows). If this is the case, then the program prints the unique solution, which is simply the values of the b column that aren't in the free rows. If the free rows are NOT 0=0, then there is no solution to the problem and the program outputs this.

If the rank is less than n, then we have free columns/variables and the possibility of infinite solutions. We check again to see if there are also free rows, and if there are, do a similar check to the one above to ensure that the free rows are 0=0 (if they are, we continue; if not, then we stop as there is no solution). From this point, we output the particular solution that comes when the free variables are set to 0. This is done by going through each column  and checking if it is free. We check if a column is free by counting its 0's and 1's (if there are m-1 0's and one 1, we know the column is free). If the column is free, the number identifying it is added to the freecol array which keeps track of the free columns, and we print a 0 for the corresponding component in the particular solution. If the column is not free, it is a pivot column, so we add the number identifying it to the pivcol array, and print the next value in the b column for the corresponding component in the particular solution. Also, we increase the bcolcounter, which is a placeholder on the b column (it goes down the b column each time we use one of its values in the particular solution--this allows us to print off the values from the b column for the correct corresponding components of the particular solution).

After we go through all the columns, we have printed off the whole particular solution--we just need the special solutions now. To do this, we cycle through the freecol array, setting each free variable = 1 once (while keeping all the other free variables = 0), in order to get its special solution. We make a 'nullvector' array that represents the vector of the current special solution we're dealing with. In this array, the free variable components are all set to 0 besides the corresponding component of the current free variable we're dealing with, which is set to 1. The pivot variable components of 'null vector' are set to the negatives of the values in the free column of arrayA that we're currently dealing with (this works b/c arrayA is in rref). Now, nullvector represents the current special solution. We print the nullvector array and repeat this for all free variables/columns, and we have our set of special solutions, i.e. a set of vectors that span the nullspace. 



3) My program is written in C and is titled 'axbsol.c'. To compile it, type the command 'gcc axbsol.c'. An executable called 'a.out' will be created. In order to run the program, you need to type './a.out' with two command-line arguments, which define the names of the input and output files. An example: './a.out input.txt output.txt'.  I'm providing a sample input file with a 4x7 rank 4 matrix, and a solution vector b. But in general, the input file format should be as follows: first line should be the m dimension, second line should be the n dimension, then after a line break put the coefficient matrix (rows separated by line breaks, and each element in a row separated by a single space). After a line break put the b vector matrix, with each value separated by a line break. If any of this is confusing, please refer to the sample input file. 